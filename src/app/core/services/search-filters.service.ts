// src/app/core/services/search-filters.service.ts
// ‚úÖ VERSION FINALE CORRIG√âE - √âmission forc√©e sur filters$

import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import {
  SearchFilters,
  DEFAULT_FILTERS,
  ActiveFilter,
  FilterType,
  SortOption
} from '../models/search-filters.model';
import { Event, EventCategory } from '../models/event.model';
import { Timestamp } from '@angular/fire/firestore';

@Injectable({
  providedIn: 'root'
})
export class SearchFiltersService {
  
  // ========================================
  // üìä √âTAT DES FILTRES (R√âACTIF)
  // ========================================
  
  private filtersSubject = new BehaviorSubject<SearchFilters>(DEFAULT_FILTERS);
  public filters$: Observable<SearchFilters> = this.filtersSubject.asObservable();
  
  // ========================================
  // üéØ GETTERS
  // ========================================
  
  getCurrentFilters(): SearchFilters {
    return this.filtersSubject.value;
  }
  
  hasActiveFilters(): boolean {
    const filters = this.getCurrentFilters();
    return (
      filters.searchTerm !== '' ||
      filters.categories.length > 0 ||
      filters.cities.length > 0 ||
      filters.dateFrom !== undefined ||
      filters.dateTo !== undefined ||
      filters.onlyAvailable ||
      filters.minParticipants !== undefined ||
      filters.maxParticipants !== undefined ||
      !filters.includePrivate
    );
  }
  
  getActiveFiltersCount(): number {
    const filters = this.getCurrentFilters();
    let count = 0;
    
    if (filters.searchTerm) count++;
    if (filters.categories.length > 0) count += filters.categories.length;
    if (filters.cities.length > 0) count += filters.cities.length;
    if (filters.dateFrom || filters.dateTo) count++;
    if (filters.onlyAvailable) count++;
    if (filters.minParticipants || filters.maxParticipants) count++;
    if (!filters.includePrivate) count++;
    
    return count;
  }
  
  // ========================================
  // üîß SETTERS (MODIFICATION DES FILTRES)
  // ========================================
  
  /**
   * ‚úÖ CORRIG√â : Force l'√©mission m√™me si la r√©f√©rence ne change pas
   */
  setFilters(filters: SearchFilters): void {
    console.log('üîç [SearchFiltersService] setFilters appel√© avec:', filters);
    
    // Cr√©e une NOUVELLE r√©f√©rence pour forcer l'√©mission
    const newFilters = { ...filters };
    this.filtersSubject.next(newFilters);
    
    console.log('üì¢ [SearchFiltersService] √âmission forc√©e sur filters$');
  }
  
  /**
   * ‚úÖ CORRIG√â : Cr√©e toujours une nouvelle r√©f√©rence
   */
  updateFilters(partialFilters: Partial<SearchFilters>): void {
    const currentFilters = this.getCurrentFilters();
    
    // ‚úÖ IMPORTANT : Cr√©e une NOUVELLE r√©f√©rence
    const newFilters = {
      ...currentFilters,
      ...partialFilters
    };
    
    console.log('üîç [SearchFiltersService] updateFilters:', {
      before: currentFilters,
      changes: partialFilters,
      after: newFilters
    });
    
    this.filtersSubject.next(newFilters);
    
    console.log('üì¢ [SearchFiltersService] √âmission sur filters$');
  }
  
  resetFilters(): void {
    console.log('üîÑ [SearchFiltersService] R√©initialisation des filtres');
    
    // Cr√©e une NOUVELLE r√©f√©rence
    const newFilters = { ...DEFAULT_FILTERS };
    this.filtersSubject.next(newFilters);
    
    console.log('üì¢ [SearchFiltersService] √âmission forc√©e sur filters$');
  }
  
  setSearchTerm(term: string): void {
    console.log('üîç [SearchFiltersService] setSearchTerm:', term);
    this.updateFilters({ searchTerm: term });
  }
  
  setSegment(segment: 'all' | 'upcoming' | 'past'): void {
    console.log('üîç [SearchFiltersService] setSegment:', segment);
    this.updateFilters({ segment });
  }
  
  toggleCategory(category: EventCategory): void {
    const filters = this.getCurrentFilters();
    
    // ‚úÖ Cr√©e un NOUVEAU tableau
    const categories = [...filters.categories];
    
    const index = categories.indexOf(category);
    if (index > -1) {
      categories.splice(index, 1);
    } else {
      categories.push(category);
    }
    
    console.log('üîç [SearchFiltersService] toggleCategory:', { category, categories });
    this.updateFilters({ categories });
  }
  
  toggleCity(city: string): void {
    const filters = this.getCurrentFilters();
    
    // ‚úÖ Cr√©e un NOUVEAU tableau
    const cities = [...filters.cities];
    
    const index = cities.indexOf(city);
    if (index > -1) {
      cities.splice(index, 1);
    } else {
      cities.push(city);
    }
    
    console.log('üîç [SearchFiltersService] toggleCity:', { city, cities });
    this.updateFilters({ cities });
  }
  
  setDateRange(from?: Date, to?: Date): void {
    console.log('üîç [SearchFiltersService] setDateRange:', { from, to });
    this.updateFilters({ dateFrom: from, dateTo: to });
  }
  
  toggleOnlyAvailable(): void {
    const filters = this.getCurrentFilters();
    const newValue = !filters.onlyAvailable;
    console.log('üîç [SearchFiltersService] toggleOnlyAvailable:', newValue);
    this.updateFilters({ onlyAvailable: newValue });
  }
  
  setSorting(sortBy: SortOption, sortOrder: 'asc' | 'desc'): void {
    console.log('üîç [SearchFiltersService] setSorting:', { sortBy, sortOrder });
    this.updateFilters({ sortBy, sortOrder });
  }
  
  // ========================================
  // üè∑Ô∏è FILTRES ACTIFS (POUR L'AFFICHAGE)
  // ========================================
  
  getActiveFiltersList(): ActiveFilter[] {
    const filters = this.getCurrentFilters();
    const activeFilters: ActiveFilter[] = [];
    
    if (filters.searchTerm) {
      activeFilters.push({
        type: FilterType.SEARCH,
        label: `"${filters.searchTerm}"`,
        value: filters.searchTerm,
        icon: 'search'
      });
    }
    
    filters.categories.forEach(cat => {
      activeFilters.push({
        type: FilterType.CATEGORY,
        label: this.getCategoryLabel(cat),
        value: cat,
        icon: 'pricetag'
      });
    });
    
    filters.cities.forEach(city => {
      activeFilters.push({
        type: FilterType.CITY,
        label: city,
        value: city,
        icon: 'location'
      });
    });
    
    if (filters.dateFrom || filters.dateTo) {
      const label = this.getDateRangeLabel(filters.dateFrom, filters.dateTo);
      activeFilters.push({
        type: FilterType.DATE_RANGE,
        label,
        value: { from: filters.dateFrom, to: filters.dateTo },
        icon: 'calendar'
      });
    }
    
    if (filters.onlyAvailable) {
      activeFilters.push({
        type: FilterType.AVAILABLE_ONLY,
        label: 'Places disponibles',
        value: true,
        icon: 'checkmark-circle'
      });
    }
    
    return activeFilters;
  }
  
  removeActiveFilter(filter: ActiveFilter): void {
    console.log('üîç [SearchFiltersService] removeActiveFilter:', filter);
    
    switch (filter.type) {
      case FilterType.SEARCH:
        this.setSearchTerm('');
        break;
        
      case FilterType.CATEGORY:
        this.toggleCategory(filter.value as EventCategory);
        break;
        
      case FilterType.CITY:
        this.toggleCity(filter.value as string);
        break;
        
      case FilterType.DATE_RANGE:
        this.setDateRange(undefined, undefined);
        break;
        
      case FilterType.AVAILABLE_ONLY:
        this.toggleOnlyAvailable();
        break;
    }
  }
  
  // ========================================
  // üîç APPLICATION DES FILTRES
  // ========================================
  
  applyFilters(
    events: Event[],
    participantCounts: Map<string, number>
  ): Event[] {
    const filters = this.getCurrentFilters();
    
    console.log('üîç [SearchFiltersService] applyFilters START:', {
      totalEvents: events.length,
      filters: filters,
      participantCountsSize: participantCounts.size
    });
    
    let filtered = [...events];
    const initialCount = filtered.length;
    
    // 1Ô∏è‚É£ Filtre par terme de recherche
    if (filters.searchTerm) {
      const term = filters.searchTerm.toLowerCase();
      const beforeCount = filtered.length;
      filtered = filtered.filter(event =>
        event.title.toLowerCase().includes(term) ||
        event.description.toLowerCase().includes(term) ||
        event.location.city.toLowerCase().includes(term)
      );
      console.log(`  1Ô∏è‚É£ Recherche "${term}": ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    
    // 2Ô∏è‚É£ Filtre par segment temporel
    const now = Timestamp.now();
    const beforeSegmentCount = filtered.length;
    
    if (filters.segment === 'upcoming') {
      filtered = filtered.filter(event => {
        const isUpcoming = event.date.toMillis() >= now.toMillis();
        return isUpcoming;
      });
      console.log(`  2Ô∏è‚É£ Segment "upcoming": ${beforeSegmentCount} ‚Üí ${filtered.length} √©v√©nements`);
    } else if (filters.segment === 'past') {
      filtered = filtered.filter(event => event.date.toMillis() < now.toMillis());
      console.log(`  2Ô∏è‚É£ Segment "past": ${beforeSegmentCount} ‚Üí ${filtered.length} √©v√©nements`);
    } else {
      console.log(`  2Ô∏è‚É£ Segment "all": ${beforeSegmentCount} √©v√©nements (pas de filtre)`);
    }
    
    // 3Ô∏è‚É£ Filtre par plage de dates personnalis√©e
    if (filters.dateFrom) {
      const beforeCount = filtered.length;
      const fromTimestamp = Timestamp.fromDate(filters.dateFrom);
      filtered = filtered.filter(event => 
        event.date.toMillis() >= fromTimestamp.toMillis()
      );
      console.log(`  3Ô∏è‚É£ Date FROM ${filters.dateFrom.toLocaleDateString()}: ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    if (filters.dateTo) {
      const beforeCount = filtered.length;
      const toTimestamp = Timestamp.fromDate(filters.dateTo);
      filtered = filtered.filter(event => 
        event.date.toMillis() <= toTimestamp.toMillis()
      );
      console.log(`  3Ô∏è‚É£ Date TO ${filters.dateTo.toLocaleDateString()}: ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    
    // 4Ô∏è‚É£ Filtre par cat√©gories
    if (filters.categories.length > 0) {
      const beforeCount = filtered.length;
      filtered = filtered.filter(event =>
        filters.categories.includes(event.category)
      );
      console.log(`  4Ô∏è‚É£ Cat√©gories ${JSON.stringify(filters.categories)}: ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    
    // 5Ô∏è‚É£ Filtre par villes
    if (filters.cities.length > 0) {
      const beforeCount = filtered.length;
      filtered = filtered.filter(event =>
        filters.cities.includes(event.location.city)
      );
      console.log(`  5Ô∏è‚É£ Villes ${JSON.stringify(filters.cities)}: ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    
    // 6Ô∏è‚É£ Filtre par disponibilit√©
    if (filters.onlyAvailable) {
      const beforeCount = filtered.length;
      filtered = filtered.filter(event => {
        const count = participantCounts.get(event.id!) || 0;
        return count < event.maxParticipants;
      });
      console.log(`  6Ô∏è‚É£ Seulement disponibles: ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    
    // 7Ô∏è‚É£ Filtre par participants (min/max)
    if (filters.minParticipants !== undefined) {
      const beforeCount = filtered.length;
      filtered = filtered.filter(event => {
        const count = participantCounts.get(event.id!) || 0;
        return count >= filters.minParticipants!;
      });
      console.log(`  7Ô∏è‚É£ Min participants ${filters.minParticipants}: ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    if (filters.maxParticipants !== undefined) {
      const beforeCount = filtered.length;
      filtered = filtered.filter(event => {
        const count = participantCounts.get(event.id!) || 0;
        return count <= filters.maxParticipants!;
      });
      console.log(`  7Ô∏è‚É£ Max participants ${filters.maxParticipants}: ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    
    // 8Ô∏è‚É£ Filtre priv√©/public
    if (!filters.includePrivate) {
      const beforeCount = filtered.length;
      filtered = filtered.filter(event => !event.isPrivate);
      console.log(`  8Ô∏è‚É£ Exclure priv√©s: ${beforeCount} ‚Üí ${filtered.length} √©v√©nements`);
    }
    
    // 9Ô∏è‚É£ Tri
    filtered = this.sortEvents(filtered, participantCounts, filters.sortBy, filters.sortOrder);
    console.log(`  9Ô∏è‚É£ Tri par ${filters.sortBy} (${filters.sortOrder})`);
    
    console.log(`üîç [SearchFiltersService] applyFilters END: ${initialCount} ‚Üí ${filtered.length} √©v√©nements`);
    
    return filtered;
  }
  
  // ========================================
  // üìä TRI
  // ========================================
  
  private sortEvents(
    events: Event[],
    participantCounts: Map<string, number>,
    sortBy: SortOption,
    sortOrder: 'asc' | 'desc'
  ): Event[] {
    const sorted = [...events];
    
    sorted.sort((a, b) => {
      let comparison = 0;
      
      switch (sortBy) {
        case SortOption.DATE:
          comparison = a.date.toMillis() - b.date.toMillis();
          break;
          
        case SortOption.POPULARITY:
          const countA = participantCounts.get(a.id!) || 0;
          const countB = participantCounts.get(b.id!) || 0;
          comparison = countA - countB;
          break;
          
        case SortOption.CREATED:
          comparison = a.createdAt.toMillis() - b.createdAt.toMillis();
          break;
          
        case SortOption.TITLE:
          comparison = a.title.localeCompare(b.title);
          break;
      }
      
      return sortOrder === 'asc' ? comparison : -comparison;
    });
    
    return sorted;
  }
  
  // ========================================
  // üõ†Ô∏è HELPERS
  // ========================================
  
  private getCategoryLabel(category: EventCategory): string {
    const labels: Record<EventCategory, string> = {
      [EventCategory.PARTY]: 'üéâ Soir√©e',
      [EventCategory.CONCERT]: 'üéµ Concert',
      [EventCategory.FESTIVAL]: 'üé™ Festival',
      [EventCategory.BAR]: 'üç∫ Bar',
      [EventCategory.CLUB]: 'üíÉ Club',
      [EventCategory.OUTDOOR]: 'üå≥ Ext√©rieur',
      [EventCategory.PRIVATE]: 'üîí Priv√©',
      [EventCategory.OTHER]: 'üìå Autre'
    };
    return labels[category] || category;
  }
  
  private getDateRangeLabel(from?: Date, to?: Date): string {
    if (from && to) {
      return `${this.formatDate(from)} - ${this.formatDate(to)}`;
    } else if (from) {
      return `Apr√®s le ${this.formatDate(from)}`;
    } else if (to) {
      return `Avant le ${this.formatDate(to)}`;
    }
    return 'Dates';
  }
  
  private formatDate(date: Date): string {
    return date.toLocaleDateString('fr-FR', {
      day: '2-digit',
      month: 'short'
    });
  }
  
  // ========================================
  // üíæ SAUVEGARDE DES PR√âF√âRENCES
  // ========================================
  
  saveFiltersToStorage(): void {
    const filters = this.getCurrentFilters();
    localStorage.setItem('partyevents_filters', JSON.stringify(filters));
    console.log('üíæ Filtres sauvegard√©s');
  }
  
  loadFiltersFromStorage(): void {
    const saved = localStorage.getItem('partyevents_filters');
    if (saved) {
      try {
        const filters = JSON.parse(saved);
        this.setFilters(filters);
        console.log('üìÇ Filtres charg√©s depuis le stockage');
      } catch (error) {
        console.error('Erreur lors du chargement des filtres:', error);
      }
    }
  }
}